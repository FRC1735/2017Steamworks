// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1735.Steamworks2017.subsystems;

import org.usfirst.frc1735.Steamworks2017.Robot;
import org.usfirst.frc1735.Steamworks2017.RobotMap;
import org.usfirst.frc1735.Steamworks2017.commands.*;
import com.ctre.CANTalon;

import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class DriveTrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final SpeedController leftMotor = RobotMap.driveTrainLeftMotor;
    private final SpeedController rightMotor = RobotMap.driveTrainRightMotor;
    private final RobotDrive robotDrive21 = RobotMap.driveTrainRobotDrive21;
    private final CANTalon fLMotor = RobotMap.driveTrainFLMotor;
    private final CANTalon fRMotor = RobotMap.driveTrainFRMotor;
    private final CANTalon bLMotor = RobotMap.driveTrainBLMotor;
    private final CANTalon bRMotor = RobotMap.driveTrainBRMotor;
    private final RobotDrive robotDrive41 = RobotMap.driveTrainRobotDrive41;
    private final Compressor compressor = RobotMap.driveTrainCompressor;
    private final Solenoid solenoid = RobotMap.driveTrainSolenoid;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new DriveWIthJoysticks());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    public void tankDriveWithJoysticks(Joystick left, Joystick right) {
    double driveLeft = left.getY();	
    double driveRight = right.getY();
    this.tankDrive(-driveLeft, -driveRight);
    
    }
    
    public void tankDrive(double driveLeft,double driveRight) {
    	robotDrive21.tankDrive(driveLeft, driveRight);
    }

    public void arcadeDrive(double moveValue,double rotateValue) {
    	boolean squaredInputs = false; // Do not use decreased sensitivity at low speeds.
    	// Make sure we are in Traction mode:
    	this.setTractionMode();
    	robotDrive41.arcadeDrive(moveValue, rotateValue, squaredInputs); // WPILIB ASSUMES non-joystick (fwd = +1).  Rotation left is positive, right is negative.
    }
    
    public void mecanumDrive(double driveX,double driveY,double rotation) {
    	double gyroAngle = 0; // Do not use a gyro to implement field-oriented driving
    	// Make sure we are in Mecanum mode:
   		this.setMecanumMode();
   		
    	// We want to call this function for autonomous, and want the input assumptions to be non-joystick.
    	// (ie. forward motion is +1 value).
    	// Because the library for Mecanum (only) assumes joystick, we invert here (And the library inverts it back)
		robotDrive41.mecanumDrive_Cartesian(driveX, -driveY, rotation, gyroAngle ); // WPILIB ASSUMES Joystick input (Y forward == -1)
    }

	public void octaCanumDriveWithJoysticks(Joystick joyLeft, Joystick joyRight) {
		// See if we can get the right-side analog joystick from the Xbox360 controller
		//System.out.println("Right controller Y value is : " + joyRight.

		//System.out.println("LJoyY="+joyLeft.getY()+" LJoyX="+joyLeft.getX() + "RJoyY="+joyRight.getY()+" RJoyX="+joyRight.getX());
		// Extract the joystick values
		double joyLeftX  = joyLeft.getX();
		double joyLeftY  = joyLeft.getY();
		double joyRightX = joyRight.getX();
		double joyRightY = joyRight.getY();
		
		// Apply the 'dead zone' guardband to the joystick inputs:
		// Centered joysticks may not actually read as zero due to spring variances.
		// Therfore, remove any small values as being "noise".
		if (joyLeftX < Robot.m_joystickFilter)
			joyLeftX = 0;
		if (joyLeftY < Robot.m_joystickFilter)
			joyLeftY = 0;
		if (joyRightX < Robot.m_joystickFilter)
			joyRightX = 0;
		if (joyRightY < Robot.m_joystickFilter)
			joyRightY = 0;
		
		
		// Find out which operating mode is requested
		if (this.isInMecanumMode()) {
			// Drive with the mecanum wheels...
			this.mecanumDrive(joyLeftX, -joyRightY, joyRightX); // X motion (crab), Y motion (fwd/rvs), rotation
		}
		else {
			// Here, we are in arcade mode w/ the traction wheels
			this.arcadeDrive(-joyRightY, -joyRightX); // fwd/rvs, rotation (CW/right is negative)
		}
	}
	
    // Function to STOP the drivetrain:
    public void stop() {
    	// Call the WPILIB code directly so we don't change modes when stopping...
    	robotDrive41.arcadeDrive(0, 0, false); //move, rotate, squaredInputs
    }
    
    public boolean isInMecanumMode() {
    	// Simply return the state of the global variable
    	return this.m_isInMecanumMode;
    }
    
    // All the things needed to enter mecanum mode
    public void setMecanumMode() {
    	// Set the global variable
    	this.m_isInMecanumMode = true;
    	
    	// Set the piston state
		this.solenoid.set(false); // release the pneumatics; gravity + "springs" will drop us back onto default mecanum wheels.
    	
    	// Set the correct motor inversion
		robotDrive41.setInvertedMotor(RobotDrive.MotorType.kFrontRight, true);
		robotDrive41.setInvertedMotor(RobotDrive.MotorType.kRearRight, true);
    	
		// Set the dashboard indicator
		SmartDashboard.putString("Drivetrain Mode", this.m_isInMecanumMode?"MECANUM":"TRACTION");	
    }
    
    // All the things needed to enter mecanum mode
    public void setTractionMode() {
    	// Set the global variable
    	this.m_isInMecanumMode = false;
    	
    	// Set the piston state
		this.solenoid.set(true); // engage the pneumatics to force the traction wheels down
    	
    	// Set the correct motor inversion
		robotDrive41.setInvertedMotor(RobotDrive.MotorType.kFrontRight, false);
		robotDrive41.setInvertedMotor(RobotDrive.MotorType.kRearRight, false);
    	
		// Set the dashboard indicator
		SmartDashboard.putString("Drivetrain Mode", this.m_isInMecanumMode?"MECANUM":"TRACTION");	
    }
    
    public void toggleDrivetrain() {
    	// Toggle the state of the driveline mode
		if (Robot.driveTrain.isInMecanumMode())
			Robot.driveTrain.setTractionMode();
		else // Must be in traction mode, so...
			Robot.driveTrain.setMecanumMode();
    }

    // Member Variables
    boolean m_isInMecanumMode;
}

